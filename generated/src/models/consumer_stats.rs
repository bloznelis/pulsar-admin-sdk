/*
 * Pulsar Admin REST API
 *
 * This provides the REST API for admin operations
 *
 * The version of the OpenAPI document: v2
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ConsumerStats {
    #[serde(rename = "address", skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
    #[serde(rename = "availablePermits", skip_serializing_if = "Option::is_none")]
    pub available_permits: Option<i32>,
    #[serde(rename = "avgMessagesPerEntry", skip_serializing_if = "Option::is_none")]
    pub avg_messages_per_entry: Option<i32>,
    #[serde(rename = "blockedConsumerOnUnackedMsgs", skip_serializing_if = "Option::is_none")]
    pub blocked_consumer_on_unacked_msgs: Option<bool>,
    #[serde(rename = "bytesOutCounter", skip_serializing_if = "Option::is_none")]
    pub bytes_out_counter: Option<i64>,
    #[serde(rename = "chunkedMessageRate", skip_serializing_if = "Option::is_none")]
    pub chunked_message_rate: Option<f64>,
    #[serde(rename = "clientVersion", skip_serializing_if = "Option::is_none")]
    pub client_version: Option<String>,
    #[serde(rename = "connectedSince", skip_serializing_if = "Option::is_none")]
    pub connected_since: Option<String>,
    #[serde(rename = "consumerName", skip_serializing_if = "Option::is_none")]
    pub consumer_name: Option<String>,
    #[serde(rename = "keyHashRanges", skip_serializing_if = "Option::is_none")]
    pub key_hash_ranges: Option<Vec<String>>,
    #[serde(rename = "lastAckedTimestamp", skip_serializing_if = "Option::is_none")]
    pub last_acked_timestamp: Option<i64>,
    #[serde(rename = "lastConsumedFlowTimestamp", skip_serializing_if = "Option::is_none")]
    pub last_consumed_flow_timestamp: Option<i64>,
    #[serde(rename = "lastConsumedTimestamp", skip_serializing_if = "Option::is_none")]
    pub last_consumed_timestamp: Option<i64>,
    #[serde(rename = "messageAckRate", skip_serializing_if = "Option::is_none")]
    pub message_ack_rate: Option<f64>,
    #[serde(rename = "metadata", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<std::collections::HashMap<String, String>>,
    #[serde(rename = "msgOutCounter", skip_serializing_if = "Option::is_none")]
    pub msg_out_counter: Option<i64>,
    #[serde(rename = "msgRateOut", skip_serializing_if = "Option::is_none")]
    pub msg_rate_out: Option<f64>,
    #[serde(rename = "msgRateRedeliver", skip_serializing_if = "Option::is_none")]
    pub msg_rate_redeliver: Option<f64>,
    #[serde(rename = "msgThroughputOut", skip_serializing_if = "Option::is_none")]
    pub msg_throughput_out: Option<f64>,
    #[serde(rename = "readPositionWhenJoining", skip_serializing_if = "Option::is_none")]
    pub read_position_when_joining: Option<String>,
    #[serde(rename = "unackedMessages", skip_serializing_if = "Option::is_none")]
    pub unacked_messages: Option<i32>,
}

impl ConsumerStats {
    pub fn new() -> ConsumerStats {
        ConsumerStats {
            address: None,
            available_permits: None,
            avg_messages_per_entry: None,
            blocked_consumer_on_unacked_msgs: None,
            bytes_out_counter: None,
            chunked_message_rate: None,
            client_version: None,
            connected_since: None,
            consumer_name: None,
            key_hash_ranges: None,
            last_acked_timestamp: None,
            last_consumed_flow_timestamp: None,
            last_consumed_timestamp: None,
            message_ack_rate: None,
            metadata: None,
            msg_out_counter: None,
            msg_rate_out: None,
            msg_rate_redeliver: None,
            msg_throughput_out: None,
            read_position_when_joining: None,
            unacked_messages: None,
        }
    }
}

