/*
 * Pulsar Admin REST API
 *
 * This provides the REST API for admin operations
 *
 * The version of the OpenAPI document: v2
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

/// ClusterData : The configuration data for a cluster
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ClusterData {
    /// Authentication parameters when client would like to connect to cluster.
    #[serde(rename = "authenticationParameters", skip_serializing_if = "Option::is_none")]
    pub authentication_parameters: Option<String>,
    /// Authentication plugin when client would like to connect to cluster.
    #[serde(rename = "authenticationPlugin", skip_serializing_if = "Option::is_none")]
    pub authentication_plugin: Option<String>,
    /// TLS certificate file for internal client, used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientCertificateFilePath", skip_serializing_if = "Option::is_none")]
    pub broker_client_certificate_file_path: Option<String>,
    /// TLS private key file for internal client, used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientKeyFilePath", skip_serializing_if = "Option::is_none")]
    pub broker_client_key_file_path: Option<String>,
    /// Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
    #[serde(rename = "brokerClientTlsEnabled", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_enabled: Option<bool>,
    /// Whether internal client use KeyStore type to authenticate with other Pulsar brokers
    #[serde(rename = "brokerClientTlsEnabledWithKeyStore", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_enabled_with_key_store: Option<bool>,
    /// TLS KeyStore path for internal client,  used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientTlsKeyStore", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_key_store: Option<String>,
    /// TLS KeyStore password for internal client,  used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientTlsKeyStorePassword", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_key_store_password: Option<String>,
    /// TLS KeyStore type configuration for internal client: JKS, PKCS12, used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientTlsKeyStoreType", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_key_store_type: Option<String>,
    /// TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientTlsTrustStore", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_trust_store: Option<String>,
    /// TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientTlsTrustStorePassword", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_trust_store_password: Option<String>,
    /// TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
    #[serde(rename = "brokerClientTlsTrustStoreType", skip_serializing_if = "Option::is_none")]
    pub broker_client_tls_trust_store_type: Option<String>,
    /// Path for the trusted TLS certificate file for outgoing connection to a server (broker)
    #[serde(rename = "brokerClientTrustCertsFilePath", skip_serializing_if = "Option::is_none")]
    pub broker_client_trust_certs_file_path: Option<String>,
    /// The broker service url (for produce and consume operations)
    #[serde(rename = "brokerServiceUrl", skip_serializing_if = "Option::is_none")]
    pub broker_service_url: Option<String>,
    /// The secured broker service url (for produce and consume operations)
    #[serde(rename = "brokerServiceUrlTls", skip_serializing_if = "Option::is_none")]
    pub broker_service_url_tls: Option<String>,
    /// listenerName when client would like to connect to cluster
    #[serde(rename = "listenerName", skip_serializing_if = "Option::is_none")]
    pub listener_name: Option<String>,
    /// A set of peer cluster names
    #[serde(rename = "peerClusterNames", skip_serializing_if = "Option::is_none")]
    pub peer_cluster_names: Option<Vec<String>>,
    /// protocol to decide type of proxy routing eg: SNI-routing
    #[serde(rename = "proxyProtocol", skip_serializing_if = "Option::is_none")]
    pub proxy_protocol: Option<ProxyProtocol>,
    /// Proxy-service url when client would like to connect to broker via proxy.
    #[serde(rename = "proxyServiceUrl", skip_serializing_if = "Option::is_none")]
    pub proxy_service_url: Option<String>,
    /// The HTTP rest service URL (for admin operations)
    #[serde(rename = "serviceUrl", skip_serializing_if = "Option::is_none")]
    pub service_url: Option<String>,
    /// The HTTPS rest service URL (for admin operations)
    #[serde(rename = "serviceUrlTls", skip_serializing_if = "Option::is_none")]
    pub service_url_tls: Option<String>,
    /// Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
    #[serde(rename = "tlsAllowInsecureConnection", skip_serializing_if = "Option::is_none")]
    pub tls_allow_insecure_connection: Option<bool>,
}

impl ClusterData {
    /// The configuration data for a cluster
    pub fn new() -> ClusterData {
        ClusterData {
            authentication_parameters: None,
            authentication_plugin: None,
            broker_client_certificate_file_path: None,
            broker_client_key_file_path: None,
            broker_client_tls_enabled: None,
            broker_client_tls_enabled_with_key_store: None,
            broker_client_tls_key_store: None,
            broker_client_tls_key_store_password: None,
            broker_client_tls_key_store_type: None,
            broker_client_tls_trust_store: None,
            broker_client_tls_trust_store_password: None,
            broker_client_tls_trust_store_type: None,
            broker_client_trust_certs_file_path: None,
            broker_service_url: None,
            broker_service_url_tls: None,
            listener_name: None,
            peer_cluster_names: None,
            proxy_protocol: None,
            proxy_service_url: None,
            service_url: None,
            service_url_tls: None,
            tls_allow_insecure_connection: None,
        }
    }
}
/// protocol to decide type of proxy routing eg: SNI-routing
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ProxyProtocol {
    #[serde(rename = "SNI")]
    Sni,
}

impl Default for ProxyProtocol {
    fn default() -> ProxyProtocol {
        Self::Sni
    }
}

