/*
 * Pulsar Admin REST API
 *
 * This provides the REST API for admin operations
 *
 * The version of the OpenAPI document: v2
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};


/// struct for typed errors of method [`persistent_topics_analyze_subscription_backlog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsAnalyzeSubscriptionBacklogError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_compact`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsCompactError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_compaction_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsCompactionStatusError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_create_missed_partitions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsCreateMissedPartitionsError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_create_non_partitioned_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsCreateNonPartitionedTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_create_partitioned_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsCreatePartitionedTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status406(),
    Status409(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_create_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsCreateSubscriptionError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_deduplication_snapshot_interval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteDeduplicationSnapshotIntervalError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_delayed_delivery_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteDelayedDeliveryPoliciesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_inactive_topic_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteInactiveTopicPoliciesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_max_unacked_messages_on_consumer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteMaxUnackedMessagesOnConsumerError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_max_unacked_messages_on_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_partitioned_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeletePartitionedTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_shadow_topics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteShadowTopicsError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteSubscriptionError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_delete_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsDeleteTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_examine_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsExamineMessageError {
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_expire_messages_for_all_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsExpireMessagesForAllSubscriptionsError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_expire_topic_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsExpireTopicMessagesError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_expire_topic_messages_0`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsExpireTopicMessages0Error {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_auto_subscription_creation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetAutoSubscriptionCreationError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_backlog`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetBacklogError {
    Status404(),
    Status412(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_backlog_quota_map`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetBacklogQuotaMapError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_backlog_size_by_message_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetBacklogSizeByMessageIdError {
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_compaction_threshold`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetCompactionThresholdError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_deduplication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetDeduplicationError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_deduplication_snapshot_interval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetDeduplicationSnapshotIntervalError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_delayed_delivery_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetDelayedDeliveryPoliciesError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_dispatcher_pause_on_ack_state_persistent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetDispatcherPauseOnAckStatePersistentError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_entry_filters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetEntryFiltersError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_inactive_topic_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetInactiveTopicPoliciesError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_internal_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetInternalStatsError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_last_message_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetLastMessageIdError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetListError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_managed_ledger_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetManagedLedgerInfoError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_consumers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxConsumersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_consumers_per_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxConsumersPerSubscriptionError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_message_size`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxMessageSizeError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_producers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxProducersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_subscriptions_per_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxSubscriptionsPerTopicError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_unacked_messages_on_consumer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxUnackedMessagesOnConsumerError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_max_unacked_messages_on_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMaxUnackedMessagesOnSubscriptionError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_message_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMessageByIdError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_message_id_by_timestamp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMessageIdByTimestampError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_message_ttl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetMessageTtlError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_offload_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetOffloadPoliciesError {
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_partitioned_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPartitionedMetadataError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_partitioned_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPartitionedStatsError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_partitioned_stats_internal`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPartitionedStatsInternalError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_partitioned_topic_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPartitionedTopicListError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_permissions_on_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPermissionsOnTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_persistence`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPersistenceError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPropertiesError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_publish_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetPublishRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_replicated_subscription_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetReplicatedSubscriptionStatusError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_replication_clusters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetReplicationClustersError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_replicator_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetReplicatorDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_retention`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetRetentionError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_schema_compatibility_strategy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSchemaCompatibilityStrategyError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_schema_validation_enforced`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSchemaValidationEnforcedError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_shadow_topics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetShadowTopicsError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetStatsError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_subscribe_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSubscribeRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_subscription_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSubscriptionDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_subscription_level_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSubscriptionLevelDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_subscription_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSubscriptionPropertiesError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_subscription_types_enabled`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSubscriptionTypesEnabledError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_get_subscriptions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGetSubscriptionsError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_grant_permissions_on_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsGrantPermissionsOnTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_offload_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsOffloadStatusError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_peek_nth_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsPeekNthMessageError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_auto_subscription_creation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveAutoSubscriptionCreationError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_backlog_quota`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveBacklogQuotaError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_compaction_threshold`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveCompactionThresholdError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_deduplication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveDeduplicationError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_dispatcher_pause_on_ack_state_persistent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveDispatcherPauseOnAckStatePersistentError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_entry_filters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveEntryFiltersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_max_consumers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveMaxConsumersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_max_consumers_per_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveMaxConsumersPerSubscriptionError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_max_message_size`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveMaxMessageSizeError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_max_producers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveMaxProducersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_max_subscriptions_per_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveMaxSubscriptionsPerTopicError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_message_ttl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveMessageTtlError {
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_offload_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveOffloadPoliciesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_persistence`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemovePersistenceError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemovePropertiesError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_publish_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemovePublishRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_replication_clusters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveReplicationClustersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_replicator_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveReplicatorDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_retention`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveRetentionError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_schema_compatibility_strategy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveSchemaCompatibilityStrategyError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_subscribe_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveSubscribeRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_subscription_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveSubscriptionDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_subscription_level_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveSubscriptionLevelDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_remove_subscription_types_enabled`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRemoveSubscriptionTypesEnabledError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_reset_cursor`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsResetCursorError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_reset_cursor_on_position`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsResetCursorOnPositionError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_revoke_permissions_on_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsRevokePermissionsOnTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_auto_subscription_creation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetAutoSubscriptionCreationError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_backlog_quota`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetBacklogQuotaError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_compaction_threshold`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetCompactionThresholdError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_deduplication`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetDeduplicationError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_deduplication_snapshot_interval`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetDeduplicationSnapshotIntervalError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_delayed_delivery_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetDelayedDeliveryPoliciesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_dispatcher_pause_on_ack_state_persistent`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetDispatcherPauseOnAckStatePersistentError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_entry_filters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetEntryFiltersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_inactive_topic_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetInactiveTopicPoliciesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_consumers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxConsumersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_consumers_per_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxConsumersPerSubscriptionError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_message_size`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxMessageSizeError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_producers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxProducersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_subscriptions_per_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxSubscriptionsPerTopicError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_unacked_messages_on_consumer`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxUnackedMessagesOnConsumerError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_max_unacked_messages_on_subscription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMaxUnackedMessagesOnSubscriptionError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_message_ttl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetMessageTtlError {
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_offload_policies`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetOffloadPoliciesError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_persistence`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetPersistenceError {
    Status400(),
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_publish_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetPublishRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_replicated_subscription_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetReplicatedSubscriptionStatusError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_replication_clusters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetReplicationClustersError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_replicator_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetReplicatorDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_retention`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetRetentionError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_schema_compatibility_strategy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetSchemaCompatibilityStrategyError {
    Status403(),
    Status404(),
    Status405(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_schema_validation_enforced`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetSchemaValidationEnforcedError {
    Status403(),
    Status404(),
    Status412(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_shadow_topics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetShadowTopicsError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_subscribe_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetSubscribeRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_subscription_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetSubscriptionDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_subscription_level_dispatch_rate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetSubscriptionLevelDispatchRateError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_set_subscription_types_enabled`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSetSubscriptionTypesEnabledError {
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_skip_all_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSkipAllMessagesError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_skip_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsSkipMessagesError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_terminate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsTerminateError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status406(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_terminate_partitioned_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsTerminatePartitionedTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_trigger_offload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsTriggerOffloadError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status409(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_trim_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsTrimTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_truncate_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsTruncateTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_unload_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsUnloadTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status412(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_update_partitioned_topic`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsUpdatePartitionedTopicError {
    Status401(),
    Status403(),
    Status404(),
    Status412(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_update_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsUpdatePropertiesError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`persistent_topics_update_subscription_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PersistentTopicsUpdateSubscriptionPropertiesError {
    Status401(),
    Status403(),
    Status404(),
    Status405(),
    Status500(),
    Status503(),
    UnknownValue(serde_json::Value),
}


pub async fn persistent_topics_analyze_subscription_backlog(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>, position: Option<models::ResetCursorData>) -> Result<(), Error<PersistentTopicsAnalyzeSubscriptionBacklogError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/analyzeBacklog", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&position);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsAnalyzeSubscriptionBacklogError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_compact(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsCompactError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/compaction", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsCompactError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_compaction_status(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsCompactionStatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/compaction", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsCompactionStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_create_missed_partitions(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str) -> Result<(), Error<PersistentTopicsCreateMissedPartitionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/createMissedPartitions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsCreateMissedPartitionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This is the only REST endpoint from which non-partitioned topics could be created.
pub async fn persistent_topics_create_non_partitioned_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, body: Option<std::collections::HashMap<String, String>>) -> Result<(), Error<PersistentTopicsCreateNonPartitionedTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsCreateNonPartitionedTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// It needs to be called before creating a producer on a partitioned topic.
pub async fn persistent_topics_create_partitioned_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, body: i32, create_local_topic_only: Option<bool>) -> Result<(), Error<PersistentTopicsCreatePartitionedTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/partitions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = create_local_topic_only {
        local_var_req_builder = local_var_req_builder.query(&[("createLocalTopicOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsCreatePartitionedTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Creates a subscription on the topic at the specified message id
pub async fn persistent_topics_create_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, subscription_name: &str, authoritative: Option<bool>, replicated: Option<bool>, message_id: Option<models::ResetCursorData>) -> Result<(), Error<PersistentTopicsCreateSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subscriptionName=crate::apis::urlencode(subscription_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = replicated {
        local_var_req_builder = local_var_req_builder.query(&[("replicated", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&message_id);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsCreateSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_delete_deduplication_snapshot_interval(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteDeduplicationSnapshotIntervalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteDeduplicationSnapshotIntervalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_delete_delayed_delivery_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteDelayedDeliveryPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/delayedDelivery", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteDelayedDeliveryPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_delete_inactive_topic_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteInactiveTopicPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteInactiveTopicPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_delete_max_unacked_messages_on_consumer(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteMaxUnackedMessagesOnConsumerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteMaxUnackedMessagesOnConsumerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_delete_max_unacked_messages_on_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// It will also delete all the partitions of the topic if it exists.
pub async fn persistent_topics_delete_partitioned_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, force: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeletePartitionedTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/partitions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = force {
        local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeletePartitionedTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_delete_shadow_topics(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteShadowTopicsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/shadowTopics", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteShadowTopicsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
pub async fn persistent_topics_delete_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, force: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = force {
        local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
pub async fn persistent_topics_delete_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, force: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsDeleteTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = force {
        local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsDeleteTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_examine_message(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, initial_position: Option<&str>, message_position: Option<i64>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsExamineMessageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/examinemessage", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = initial_position {
        local_var_req_builder = local_var_req_builder.query(&[("initialPosition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = message_position {
        local_var_req_builder = local_var_req_builder.query(&[("messagePosition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsExamineMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_expire_messages_for_all_subscriptions(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, expire_time_in_seconds: i32, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsExpireMessagesForAllSubscriptionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), expireTimeInSeconds=expire_time_in_seconds);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsExpireMessagesForAllSubscriptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_expire_topic_messages(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>, message_id: Option<models::ResetCursorData>) -> Result<(), Error<PersistentTopicsExpireTopicMessagesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&message_id);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsExpireTopicMessagesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_expire_topic_messages_0(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, expire_time_in_seconds: i32, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsExpireTopicMessages0Error>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name), expireTimeInSeconds=expire_time_in_seconds);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsExpireTopicMessages0Error> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_auto_subscription_creation(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetAutoSubscriptionCreationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/autoSubscriptionCreation", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetAutoSubscriptionCreationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_backlog(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<models::PersistentOfflineTopicStats, Error<PersistentTopicsGetBacklogError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/backlog", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetBacklogError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_backlog_quota_map(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, authoritative: Option<bool>, is_global: Option<bool>) -> Result<std::collections::HashMap<String, models::BacklogQuota>, Error<PersistentTopicsGetBacklogQuotaMapError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetBacklogQuotaMapError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_backlog_size_by_message_id(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<i64, Error<PersistentTopicsGetBacklogSizeByMessageIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/backlogSize", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetBacklogSizeByMessageIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_compaction_threshold(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i64, Error<PersistentTopicsGetCompactionThresholdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/compactionThreshold", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetCompactionThresholdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_deduplication(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<bool, Error<PersistentTopicsGetDeduplicationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetDeduplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_deduplication_snapshot_interval(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetDeduplicationSnapshotIntervalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetDeduplicationSnapshotIntervalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_delayed_delivery_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, applied: Option<bool>, authoritative: Option<bool>) -> Result<models::DelayedDeliveryPolicies, Error<PersistentTopicsGetDelayedDeliveryPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/delayedDelivery", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetDelayedDeliveryPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/dispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_dispatcher_pause_on_ack_state_persistent(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetDispatcherPauseOnAckStatePersistentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/dispatcherPauseOnAckStatePersistent", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetDispatcherPauseOnAckStatePersistentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_entry_filters(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetEntryFiltersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/entryFilters", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetEntryFiltersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_inactive_topic_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<models::InactiveTopicPolicies, Error<PersistentTopicsGetInactiveTopicPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetInactiveTopicPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_internal_stats(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, metadata: Option<bool>) -> Result<models::PersistentTopicInternalStats, Error<PersistentTopicsGetInternalStatsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/internalStats", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = metadata {
        local_var_req_builder = local_var_req_builder.query(&[("metadata", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetInternalStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_last_message_id(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetLastMessageIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/lastMessageId", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetLastMessageIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_list(configuration: &configuration::Configuration, tenant: &str, namespace: &str, bundle: Option<&str>, include_system_topic: Option<bool>) -> Result<Vec<String>, Error<PersistentTopicsGetListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = bundle {
        local_var_req_builder = local_var_req_builder.query(&[("bundle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_system_topic {
        local_var_req_builder = local_var_req_builder.query(&[("includeSystemTopic", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_managed_ledger_info(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<models::PartitionedManagedLedgerInfo, Error<PersistentTopicsGetManagedLedgerInfoError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/internal-info", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetManagedLedgerInfoError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_consumers(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, applied: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxConsumersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxConsumers", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxConsumersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_consumers_per_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxConsumersPerSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxConsumersPerSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_message_size(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxMessageSizeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxMessageSize", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxMessageSizeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_producers(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxProducersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxProducers", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxProducersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_subscriptions_per_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxSubscriptionsPerTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxSubscriptionsPerTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_unacked_messages_on_consumer(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxUnackedMessagesOnConsumerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxUnackedMessagesOnConsumerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_max_unacked_messages_on_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMaxUnackedMessagesOnSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMaxUnackedMessagesOnSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_message_by_id(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, ledger_id: i64, entry_id: i64, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetMessageByIdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), ledgerId=ledger_id, entryId=entry_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetMessageByIdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_message_id_by_timestamp(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, timestamp: i64, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetMessageIdByTimestampError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), timestamp=timestamp);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetMessageIdByTimestampError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_message_ttl(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<i32, Error<PersistentTopicsGetMessageTtlError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/messageTTL", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetMessageTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_offload_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetOffloadPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/offloadPolicies", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetOffloadPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_partitioned_metadata(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, check_allow_auto_creation: Option<bool>) -> Result<models::PartitionedTopicMetadata, Error<PersistentTopicsGetPartitionedMetadataError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/partitions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = check_allow_auto_creation {
        local_var_req_builder = local_var_req_builder.query(&[("checkAllowAutoCreation", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPartitionedMetadataError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_partitioned_stats(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, per_partition: Option<bool>, authoritative: Option<bool>, get_precise_backlog: Option<bool>, subscription_backlog_size: Option<bool>, get_earliest_time_in_backlog: Option<bool>, exclude_publishers: Option<bool>, exclude_consumers: Option<bool>) -> Result<models::PartitionedTopicStatsImpl, Error<PersistentTopicsGetPartitionedStatsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/partitioned-stats", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = per_partition {
        local_var_req_builder = local_var_req_builder.query(&[("perPartition", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = get_precise_backlog {
        local_var_req_builder = local_var_req_builder.query(&[("getPreciseBacklog", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = subscription_backlog_size {
        local_var_req_builder = local_var_req_builder.query(&[("subscriptionBacklogSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = get_earliest_time_in_backlog {
        local_var_req_builder = local_var_req_builder.query(&[("getEarliestTimeInBacklog", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_publishers {
        local_var_req_builder = local_var_req_builder.query(&[("excludePublishers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_consumers {
        local_var_req_builder = local_var_req_builder.query(&[("excludeConsumers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPartitionedStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_partitioned_stats_internal(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<models::PartitionedTopicInternalStats, Error<PersistentTopicsGetPartitionedStatsInternalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/partitioned-internalStats", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPartitionedStatsInternalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_partitioned_topic_list(configuration: &configuration::Configuration, tenant: &str, namespace: &str, include_system_topic: Option<bool>) -> Result<Vec<String>, Error<PersistentTopicsGetPartitionedTopicListError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/partitioned", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_system_topic {
        local_var_req_builder = local_var_req_builder.query(&[("includeSystemTopic", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPartitionedTopicListError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
pub async fn persistent_topics_get_permissions_on_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str) -> Result<(), Error<PersistentTopicsGetPermissionsOnTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/permissions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetPermissionsOnTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_persistence(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<models::PersistencePolicies, Error<PersistentTopicsGetPersistenceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/persistence", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPersistenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_properties(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<std::collections::HashMap<String, String>, Error<PersistentTopicsGetPropertiesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/properties", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_publish_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<models::PublishRate, Error<PersistentTopicsGetPublishRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/publishRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetPublishRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_replicated_subscription_status(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>) -> Result<std::collections::HashMap<String, bool>, Error<PersistentTopicsGetReplicatedSubscriptionStatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetReplicatedSubscriptionStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_replication_clusters(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, authoritative: Option<bool>) -> Result<Vec<String>, Error<PersistentTopicsGetReplicationClustersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/replication", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetReplicationClustersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_replicator_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, applied: Option<bool>, authoritative: Option<bool>) -> Result<models::DispatchRate, Error<PersistentTopicsGetReplicatorDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetReplicatorDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_retention(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, applied: Option<bool>, authoritative: Option<bool>) -> Result<models::RetentionPolicies, Error<PersistentTopicsGetRetentionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/retention", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetRetentionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_schema_compatibility_strategy(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, authoritative: Option<bool>) -> Result<String, Error<PersistentTopicsGetSchemaCompatibilityStrategyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetSchemaCompatibilityStrategyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_schema_validation_enforced(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetSchemaValidationEnforcedError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetSchemaValidationEnforcedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_shadow_topics(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetShadowTopicsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/shadowTopics", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetShadowTopicsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_stats(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, get_precise_backlog: Option<bool>, subscription_backlog_size: Option<bool>, get_earliest_time_in_backlog: Option<bool>, exclude_publishers: Option<bool>, exclude_consumers: Option<bool>) -> Result<models::PersistentTopicStats, Error<PersistentTopicsGetStatsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/stats", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = get_precise_backlog {
        local_var_req_builder = local_var_req_builder.query(&[("getPreciseBacklog", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = subscription_backlog_size {
        local_var_req_builder = local_var_req_builder.query(&[("subscriptionBacklogSize", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = get_earliest_time_in_backlog {
        local_var_req_builder = local_var_req_builder.query(&[("getEarliestTimeInBacklog", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_publishers {
        local_var_req_builder = local_var_req_builder.query(&[("excludePublishers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = exclude_consumers {
        local_var_req_builder = local_var_req_builder.query(&[("excludeConsumers", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_subscribe_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<models::SubscribeRate, Error<PersistentTopicsGetSubscribeRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscribeRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetSubscribeRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_subscription_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<models::DispatchRate, Error<PersistentTopicsGetSubscriptionDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetSubscriptionDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_subscription_level_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, applied: Option<bool>, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetSubscriptionLevelDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = applied {
        local_var_req_builder = local_var_req_builder.query(&[("applied", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetSubscriptionLevelDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_subscription_properties(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsGetSubscriptionPropertiesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/properties", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGetSubscriptionPropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_subscription_types_enabled(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<Vec<String>, Error<PersistentTopicsGetSubscriptionTypesEnabledError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetSubscriptionTypesEnabledError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_get_subscriptions(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<Vec<String>, Error<PersistentTopicsGetSubscriptionsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PersistentTopicsGetSubscriptionsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_grant_permissions_on_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, role: &str, body: Option<Vec<String>>) -> Result<(), Error<PersistentTopicsGrantPermissionsOnTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/permissions/{role}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsGrantPermissionsOnTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_offload_status(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsOffloadStatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/offload", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsOffloadStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_peek_nth_message(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, message_position: i32, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsPeekNthMessageError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name), messagePosition=message_position);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsPeekNthMessageError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_auto_subscription_creation(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveAutoSubscriptionCreationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/autoSubscriptionCreation", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveAutoSubscriptionCreationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_backlog_quota(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, backlog_quota_type: Option<&str>, authoritative: Option<bool>, is_global: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveBacklogQuotaError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/backlogQuota", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = backlog_quota_type {
        local_var_req_builder = local_var_req_builder.query(&[("backlogQuotaType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveBacklogQuotaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_compaction_threshold(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveCompactionThresholdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/compactionThreshold", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveCompactionThresholdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_deduplication(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveDeduplicationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveDeduplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/dispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_dispatcher_pause_on_ack_state_persistent(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveDispatcherPauseOnAckStatePersistentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/dispatcherPauseOnAckStatePersistent", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveDispatcherPauseOnAckStatePersistentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_entry_filters(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveEntryFiltersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/entryFilters", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveEntryFiltersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_max_consumers(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveMaxConsumersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxConsumers", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveMaxConsumersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_max_consumers_per_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveMaxConsumersPerSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveMaxConsumersPerSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_max_message_size(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveMaxMessageSizeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxMessageSize", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveMaxMessageSizeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_max_producers(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveMaxProducersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxProducers", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveMaxProducersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_max_subscriptions_per_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveMaxSubscriptionsPerTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveMaxSubscriptionsPerTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_message_ttl(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveMessageTtlError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/messageTTL", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveMessageTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_offload_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveOffloadPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/offloadPolicies", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveOffloadPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_persistence(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemovePersistenceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/persistence", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemovePersistenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_properties(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, key: Option<&str>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemovePropertiesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/properties", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = key {
        local_var_req_builder = local_var_req_builder.query(&[("key", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemovePropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_publish_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemovePublishRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/publishRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemovePublishRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_replication_clusters(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveReplicationClustersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/replication", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveReplicationClustersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_replicator_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveReplicatorDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveReplicatorDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_retention(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveRetentionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/retention", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveRetentionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_schema_compatibility_strategy(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, body: Option<&str>) -> Result<(), Error<PersistentTopicsRemoveSchemaCompatibilityStrategyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveSchemaCompatibilityStrategyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_subscribe_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::SubscribeRate>) -> Result<(), Error<PersistentTopicsRemoveSubscribeRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscribeRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveSubscribeRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_subscription_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveSubscriptionDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveSubscriptionDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_subscription_level_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveSubscriptionLevelDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveSubscriptionLevelDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_remove_subscription_types_enabled(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsRemoveSubscriptionTypesEnabledError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRemoveSubscriptionTypesEnabledError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// It fence cursor and disconnects all active consumers before resetting cursor.
pub async fn persistent_topics_reset_cursor(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, timestamp: i64, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsResetCursorError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name), timestamp=timestamp);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsResetCursorError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// It fence cursor and disconnects all active consumers before resetting cursor.
pub async fn persistent_topics_reset_cursor_on_position(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>, message_id: Option<models::ResetCursorData>) -> Result<(), Error<PersistentTopicsResetCursorOnPositionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&message_id);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsResetCursorOnPositionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
pub async fn persistent_topics_revoke_permissions_on_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, role: &str) -> Result<(), Error<PersistentTopicsRevokePermissionsOnTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/permissions/{role}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), role=crate::apis::urlencode(role));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsRevokePermissionsOnTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_auto_subscription_creation(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::AutoSubscriptionCreationOverrideImpl>) -> Result<(), Error<PersistentTopicsSetAutoSubscriptionCreationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/autoSubscriptionCreation", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetAutoSubscriptionCreationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_backlog_quota(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, backlog_quota_type: Option<&str>, body: Option<models::BacklogQuotaImpl>) -> Result<(), Error<PersistentTopicsSetBacklogQuotaError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/backlogQuota", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = backlog_quota_type {
        local_var_req_builder = local_var_req_builder.query(&[("backlogQuotaType", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetBacklogQuotaError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_compaction_threshold(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<i64>) -> Result<(), Error<PersistentTopicsSetCompactionThresholdError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/compactionThreshold", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetCompactionThresholdError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_deduplication(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<bool>) -> Result<(), Error<PersistentTopicsSetDeduplicationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetDeduplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_deduplication_snapshot_interval(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetDeduplicationSnapshotIntervalError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetDeduplicationSnapshotIntervalError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_delayed_delivery_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::DelayedDeliveryPolicies>) -> Result<(), Error<PersistentTopicsSetDelayedDeliveryPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/delayedDelivery", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetDelayedDeliveryPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::DispatchRateImpl>) -> Result<(), Error<PersistentTopicsSetDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/dispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_dispatcher_pause_on_ack_state_persistent(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>) -> Result<(), Error<PersistentTopicsSetDispatcherPauseOnAckStatePersistentError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/dispatcherPauseOnAckStatePersistent", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetDispatcherPauseOnAckStatePersistentError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_entry_filters(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::EntryFilters>) -> Result<(), Error<PersistentTopicsSetEntryFiltersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/entryFilters", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetEntryFiltersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_inactive_topic_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::InactiveTopicPolicies>) -> Result<(), Error<PersistentTopicsSetInactiveTopicPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetInactiveTopicPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_consumers(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxConsumersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxConsumers", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxConsumersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_consumers_per_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxConsumersPerSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxConsumersPerSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_message_size(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxMessageSizeError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxMessageSize", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxMessageSizeError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_producers(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxProducersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxProducers", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxProducersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_subscriptions_per_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxSubscriptionsPerTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxSubscriptionsPerTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_unacked_messages_on_consumer(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxUnackedMessagesOnConsumerError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxUnackedMessagesOnConsumerError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_max_unacked_messages_on_subscription(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<i32>) -> Result<(), Error<PersistentTopicsSetMaxUnackedMessagesOnSubscriptionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMaxUnackedMessagesOnSubscriptionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_message_ttl(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, message_ttl: i32, is_global: Option<bool>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSetMessageTtlError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/messageTTL", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("messageTTL", &message_ttl.to_string())]);
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetMessageTtlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_offload_policies(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::OffloadPoliciesImpl>) -> Result<(), Error<PersistentTopicsSetOffloadPoliciesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/offloadPolicies", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetOffloadPoliciesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_persistence(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::PersistencePolicies>) -> Result<(), Error<PersistentTopicsSetPersistenceError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/persistence", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetPersistenceError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_publish_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::PublishRate>) -> Result<(), Error<PersistentTopicsSetPublishRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/publishRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetPublishRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_replicated_subscription_status(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, body: bool, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSetReplicatedSubscriptionStatusError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetReplicatedSubscriptionStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_replication_clusters(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, body: Vec<String>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSetReplicationClustersError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/replication", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetReplicationClustersError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_replicator_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::DispatchRateImpl>) -> Result<(), Error<PersistentTopicsSetReplicatorDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetReplicatorDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_retention(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::RetentionPolicies>) -> Result<(), Error<PersistentTopicsSetRetentionError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/retention", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetRetentionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_schema_compatibility_strategy(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, body: Option<&str>) -> Result<(), Error<PersistentTopicsSetSchemaCompatibilityStrategyError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetSchemaCompatibilityStrategyError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_schema_validation_enforced(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, body: bool, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSetSchemaValidationEnforcedError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetSchemaValidationEnforcedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_shadow_topics(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, body: Vec<String>, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSetShadowTopicsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/shadowTopics", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetShadowTopicsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_subscribe_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<models::SubscribeRate>) -> Result<(), Error<PersistentTopicsSetSubscribeRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscribeRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetSubscribeRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_subscription_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::DispatchRateImpl>) -> Result<(), Error<PersistentTopicsSetSubscriptionDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetSubscriptionDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_subscription_level_dispatch_rate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>, is_global: Option<bool>, body: Option<models::DispatchRateImpl>) -> Result<(), Error<PersistentTopicsSetSubscriptionLevelDispatchRateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetSubscriptionLevelDispatchRateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_set_subscription_types_enabled(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, is_global: Option<bool>, authoritative: Option<bool>, body: Option<Vec<String>>) -> Result<(), Error<PersistentTopicsSetSubscriptionTypesEnabledError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_global {
        local_var_req_builder = local_var_req_builder.query(&[("isGlobal", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSetSubscriptionTypesEnabledError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Completely clears the backlog on the subscription.
pub async fn persistent_topics_skip_all_messages(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSkipAllMessagesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSkipAllMessagesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_skip_messages(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, num_messages: i32, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsSkipMessagesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name), numMessages=num_messages);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsSkipMessagesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_terminate(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsTerminateError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/terminate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsTerminateError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_terminate_partitioned_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsTerminatePartitionedTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/terminate/partitions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsTerminatePartitionedTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_trigger_offload(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsTriggerOffloadError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/offload", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsTriggerOffloadError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_trim_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsTrimTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/trim", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsTrimTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// The truncate operation will move all cursors to the end of the topic and delete all inactive ledgers.
pub async fn persistent_topics_truncate_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsTruncateTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/truncate", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsTruncateTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_unload_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>) -> Result<(), Error<PersistentTopicsUnloadTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/unload", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsUnloadTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// It increments partitions of existing partitioned-topic
pub async fn persistent_topics_update_partitioned_topic(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, body: i32, update_local_topic_only: Option<bool>, authoritative: Option<bool>, force: Option<bool>) -> Result<(), Error<PersistentTopicsUpdatePartitionedTopicError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/partitions", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = update_local_topic_only {
        local_var_req_builder = local_var_req_builder.query(&[("updateLocalTopicOnly", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = force {
        local_var_req_builder = local_var_req_builder.query(&[("force", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsUpdatePartitionedTopicError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_update_properties(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, authoritative: Option<bool>, body: Option<std::collections::HashMap<String, String>>) -> Result<(), Error<PersistentTopicsUpdatePropertiesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/properties", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsUpdatePropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn persistent_topics_update_subscription_properties(configuration: &configuration::Configuration, tenant: &str, namespace: &str, topic: &str, sub_name: &str, authoritative: Option<bool>, body: Option<std::collections::HashMap<String, String>>) -> Result<(), Error<PersistentTopicsUpdateSubscriptionPropertiesError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/properties", local_var_configuration.base_path, tenant=crate::apis::urlencode(tenant), namespace=crate::apis::urlencode(namespace), topic=crate::apis::urlencode(topic), subName=crate::apis::urlencode(sub_name));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = authoritative {
        local_var_req_builder = local_var_req_builder.query(&[("authoritative", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<PersistentTopicsUpdateSubscriptionPropertiesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

